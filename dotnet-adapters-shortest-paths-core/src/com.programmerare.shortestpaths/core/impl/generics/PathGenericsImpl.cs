/*
* Copyright (c) Tomas Johansson , http://www.programmerare.com
* The code in this "core" project is licensed with MIT.
* Other projects within this Visual Studio solution may be released with other licenses e.g. Apache.
* Please find more information in the files "License.txt" and "NOTICE.txt" 
* in the project root directory and/or in the solution root directory.
* It should also be possible to find more license information at this URL:
* https://github.com/TomasJohansson/adapters-shortest-paths-dotnet/
*/

using static Programmerare.ShortestPaths.Core.Impl.WeightImpl; // SMALL_DELTA_VALUE_FOR_WEIGHT_COMPARISONS
using Programmerare.ShortestPaths.Core.Api;
using Programmerare.ShortestPaths.Core.Api.Generics;
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;

namespace Programmerare.ShortestPaths.Core.Impl.Generics
{
    public class PathGenericsImpl<E, V, W> : PathGenerics<E, V, W> 
        where E : EdgeGenerics<V, W>
        where V :Vertex
        where W : Weight
    {
	    private readonly W totalWeight;
	    private readonly IList<E> edges;

	    public static PathGenerics<E, V, W> CreatePathGenerics<E, V, W>(
		    W totalWeight, 
            IList<E> edges
	    )
            where E : EdgeGenerics<V, W>
            where V :Vertex
            where W : Weight            
        {
		    return CreatePathGenerics<E, V, W>(totalWeight, edges, false, false);
	    }

        /// <typeparam name="E">Edge</typeparam>
        /// <typeparam name="V">Vertex</typeparam>
        /// <typeparam name="W">Weight</typeparam>
        /// <param name="totalWeight">total weight</param>
        /// <param name="edges">list of edges</param>
        /// <param name="shouldThrowExceptionIfTotalWeightIsMismatching">flag for deciding if exception is desired if there is a mismatch in the total weight (which is redundant available in a convenience method but also summable from the list of edges and therefore might mismatch) </param>
        /// <param name="shouldThrowExceptionIfAnyMismatchingVertex">flag for deciding if exception is desired if there is a mismatch in the vertices of the path edges (i.e. if not the end vertex is the same as the start vertex for the next edge)</param>
        /// <returns>an instance of PathGenericsImpl</returns>
	    public static PathGenerics<E, V, W> CreatePathGenerics<E, V, W>(
		    W totalWeight, 
		    IList<E> edges, 
		    bool shouldThrowExceptionIfTotalWeightIsMismatching, 
		    bool shouldThrowExceptionIfAnyMismatchingVertex
	    )
            where E : EdgeGenerics<V, W>
            where V :Vertex
            where W : Weight            
        {
		    if(shouldThrowExceptionIfTotalWeightIsMismatching) {
			    if(IsTotalWeightNotCorrect<E, V, W>(edges, totalWeight)) {
                    // TODO: choose a better exception to throw
				    throw new Exception("Incorrect weight " + totalWeight + " not mathcing the sum of the edges " + edges);
			    }			
		    }
		    if(shouldThrowExceptionIfAnyMismatchingVertex) {
			    if(IsAnyVertexMismatching<E, V, W>(edges)) {
				    throw new Exception("Mismatching vertices detected " + edges);
			    }
		    }
		    return new PathGenericsImpl<E, V, W>(totalWeight, edges);
	    }	
	
	    private static bool IsTotalWeightNotCorrect<E, V, W>(IList<E> edges, W totalWeight)
            where E : EdgeGenerics<V, W>
            where V : Vertex
            where W : Weight
        {
		    double tot = 0;
		    foreach (E edge in edges) {
			    tot += edge.EdgeWeight.WeightValue;
		    }
		    return Math.Abs(totalWeight.WeightValue- tot) > SMALL_DELTA_VALUE_FOR_WEIGHT_COMPARISONS;
	    }

	    private static bool IsAnyVertexMismatching<E, V, W>(IList<E> edges)
            where E : EdgeGenerics<V, W>
            where V : Vertex
            where W : Weight
        {
		    for (int i = 1; i < edges.Count; i++) {
			    E edge = edges[i-1];
			    E nextEdge = edges[i];
			    if(!edge.EndVertex.Equals(nextEdge.StartVertex)) {
				    return true;
			    }
		    }
		    return false;
	    }

	    protected PathGenericsImpl(
		    W totalWeight, 
		    IList<E> edges
	    ) {
		    this.totalWeight = totalWeight;
		    this.edges = new ReadOnlyCollection<E>(edges);
	    }

        public W TotalWeightForPath => totalWeight;

        public IList<E> EdgesForPath => edges;

        // The three methods below were generated by Eclipse 
        // (and this C# code has then later been translated from the Java version)

        public override string ToString() {
		    return "PathImpl [totalWeight=" + totalWeight + ", edges=" + edges + "]";
	    }

	    public override int GetHashCode() {
		    int prime = 31;
		    int result = 1;
		    result = prime * result + ((edges == null) ? 0 : edges.GetHashCode());
		    result = prime * result + ((totalWeight == null) ? 0 : totalWeight.GetHashCode());
		    return result;
	    }

	    public override bool Equals(object obj) {
		    if (this == obj)
			    return true;
		    if (obj == null)
			    return false;
		    if (!(obj is PathGenericsImpl<E, V, W>))
			    return false;
		    PathGenericsImpl<E, V, W> other = (PathGenericsImpl<E, V, W>) obj;
		    if (edges == null) {
			    if (other.edges != null)
				    return false;
		    } else if (!edges.Equals(other.edges))
			    return false;
		    if (totalWeight == null) {
			    if (other.totalWeight != null)
				    return false;
		    } else if (!totalWeight.Equals(other.totalWeight))
			    return false;
		    return true;
	    }
    }
}