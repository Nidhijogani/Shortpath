/*
* Copyright (c) Tomas Johansson , http://www.programmerare.com
* The code in the "core" project is licensed with MIT.
* Other projects within this Visual Studio solution may be released with other licenses e.g. Apache.
* Please find more information in the files "License.txt" and "NOTICE.txt" 
* in the project root directory and/or in the solution root directory.
* It should also be possible to find more license information at this URL:
* https://github.com/TomasJohansson/adapters-shortest-paths-dotnet/
*/

namespace Programmerare.ShortestPaths.Utils
{
    //[TestFixture]
    //public class EdgeUtilityTest {

	   // EdgeUtility<EdgeGenerics<Vertex,Weight>, Vertex, Weight> edgeUtility;
	   // private const string A = "A";
	   // private const string B = "B";
	   // private const string C = "C";
	   // private const string D = "D";
	
	   // private static double weightBaseValueFor_A_B = 1;
	   // private static double weightBaseValueFor_B_C = 2;
	   // private static double weightBaseValueFor_C_D = 3;
	
	
	   // private List<EdgeGenerics<Vertex, Weight>> edges = new ArrayList<EdgeGenerics<Vertex, Weight>>();
	   // // there will be 12 edges, 3 (A_B , B_C , C_D) for each multiplier value below
	
	   // private readonly static List<int> multipliers = new List<int> {10, 1, 1000, 100 };
	
	   // private const int numberOfEdgesPerMultiplier = 3;

	   // // the indeces below refer to the list of edges cnostructed in the setup method by iterating the multiplier
	   // private const int startIndexForFirst = 0;
	   // private const int startIndexForSmallest = startIndexForFirst + numberOfEdgesPerMultiplier;
	   // private const int startIndexForLargest = startIndexForSmallest + numberOfEdgesPerMultiplier;
	   // private const int startIndexForLast = startIndexForLargest + numberOfEdgesPerMultiplier;
	
	   // [SetUp]
	   // public void setUp()  {
		  //  edgeUtility = EdgeUtility.create();
		  //  edges = new List<EdgeGenerics<Vertex, Weight>>();
		  //  foreach (int multiplier in multipliers) {
			 //   edges.Add(createEdgeGenerics(createVertex(A), createVertex(B), createWeight(weightBaseValueFor_A_B * multiplier)));
			 //   edges.Add(createEdgeGenerics(createVertex(B), createVertex(C), createWeight(weightBaseValueFor_B_C * multiplier)));
			 //   edges.Add(createEdgeGenerics(createVertex(C), createVertex(D), createWeight(weightBaseValueFor_C_D * multiplier)));
		  //  }
		  //  AreEqual(3 * multipliers.Count, edges.Count);
	   // }

	   // [Test]
	   // public void testGetEdgesWithoutDuplicates_Selecting_First() {
		  //  List<EdgeGenerics<Vertex, Weight>> result = edgeUtility.getEdgesWithoutDuplicates(edges, SelectionStrategyWhenEdgesAreDuplicated.FIRST_IN_LIST_OF_EDGES);
		  //  assertResult(result, startIndexForFirst);
	   // }

	   // [Test]
	   // public void testGetEdgesWithoutDuplicates_Selecting_Last() {
		  //  List<EdgeGenerics<Vertex, Weight>> result = edgeUtility.getEdgesWithoutDuplicates(edges, SelectionStrategyWhenEdgesAreDuplicated.LAST_IN_LIST_OF_EDGES);
		  //  assertResult(result, startIndexForLast);
	   // }

	   // [Test]
	   // public void testGetEdgesWithoutDuplicates_Selecting_Smallest() {
		  //  List<EdgeGenerics<Vertex, Weight>> result = edgeUtility.getEdgesWithoutDuplicates(edges, SelectionStrategyWhenEdgesAreDuplicated.SMALLEST_WEIGHT);
		  //  assertResult(result, startIndexForSmallest);
	   // }
	
	   // [Test]
	   // public void testGetEdgesWithoutDuplicates_Selecting_Largest() {
		  //  List<EdgeGenerics<Vertex, Weight>> result = edgeUtility.getEdgesWithoutDuplicates(edges, SelectionStrategyWhenEdgesAreDuplicated.LARGEST_WEIGHT);
		  //  assertResult(result, startIndexForLargest);
	   // }

	   // private void assertResult(List<EdgeGenerics<Vertex, Weight>> result, int startIndex) {
		  //  AreEqual(3, result.Count);
		  //  AreEqual(edges[startIndex++], result[0]);
		  //  AreEqual(edges[startIndex++], result[1]);
		  //  AreEqual(edges[startIndex], result[2]);
	   // }	
    //}
}